"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupMockUsingHostContractsArtifacts = setupMockUsingHostContractsArtifacts;
const mock_utils_1 = require("@fhevm/mock-utils");
const node_1 = require("@zama-fhe/relayer-sdk/node");
const debug_1 = __importDefault(require("debug"));
const ethers_1 = require("ethers");
const path = __importStar(require("path"));
const picocolors = __importStar(require("picocolors"));
const error_1 = require("../../error");
const constants_1 = __importDefault(require("../constants"));
const error_2 = require("../error");
const ethers_2 = require("../utils/ethers");
const addresses_1 = require("./addresses");
const debug = (0, debug_1.default)("@fhevm/hardhat:setup");
function __logDeploy(contractName, contractAddress, artifactPath) {
    debug(`Deploy ${picocolors.cyanBright(contractName)} at ${contractAddress} using artifact ${artifactPath}`);
}
function __logAlreadyDeployed(contractName, contractAddress, artifactPath) {
    debug(`${picocolors.cyanBright(contractName)} is already deployed at ${contractAddress} using artifact ${artifactPath}`);
}
async function __tryDeploy(mockProvider, contractName, contractAddress, artifactPath, bytecode) {
    try {
        const deployedBytecode = await mockProvider.getCodeAt(contractAddress);
        if (deployedBytecode === bytecode) {
            __logAlreadyDeployed(contractName, contractAddress, artifactPath);
            return {
                deployed: true,
                alreadyDeployed: true,
            };
        }
        else {
            (0, error_2.assertHHFhevm)(deployedBytecode === "0x", `${contractName} contract's bytecode at ${contractAddress} is not empty.`);
            __logDeploy(contractName, contractAddress, artifactPath);
            await mockProvider.setCodeAt(contractAddress, bytecode);
            return {
                deployed: true,
                alreadyDeployed: false,
            };
        }
    }
    catch (e) {
        debug(`Deploy ${contractName} at address ${contractAddress} using artifact at ${artifactPath} failed.`);
        throw e;
    }
}
function __logCallFuncFailed(contractName, contractAddress, funcName) {
    debug(`${picocolors.bgRedBright(picocolors.bold("ERROR"))} invalid deployed ${contractName} contact at ${contractAddress}. Function ${funcName} does not exist.`);
}
async function __tryCallGetFHEVMExecutorAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getFHEVMExecutorAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getFHEVMExecutorAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
async function __tryCallGetACLAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getACLAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getACLAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
async function __tryCallGetHCULimitAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getHCULimitAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getHCULimitAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
async function __tryCallGetInputVerifierAddress(contract, contractName, contractAddress) {
    try {
        return await contract.getInputVerifierAddress();
    }
    catch {
        __logCallFuncFailed(contractName, contractAddress, "getInputVerifierAddress()");
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name} contracts.`);
    }
}
function __resovePkgPath(packageName, root) {
    try {
        const pkgPath = require.resolve(path.join(packageName, "package.json"), {
            paths: [root],
        });
        return pkgPath;
    }
    catch (e) {
        console.error(`${picocolors.redBright(`Package resolution failed: package name: ${packageName}, root: ${root}`)}`);
        console.error(e);
        throw e;
    }
}
function __requireResolve(packageName) {
    const pkgPath = __resovePkgPath(packageName, __dirname);
    const pkgJson = require(pkgPath);
    const pkg = require(path.join(packageName, "package.json"));
    (0, error_2.assertHHFhevm)(pkgJson.version === pkg.version, `__requireResolve(${packageName}) version mismatch`);
    return { version: pkg.version, packagePath: pkgPath };
}
function __requireConsumerResolve(packageName, root) {
    const pkgPath = __resovePkgPath(packageName, root);
    const pkg = require(pkgPath);
    return { version: pkg.version, packagePath: pkgPath };
}
function __assertPkgVersion(pkg, expectedPkg) {
    if (pkg.version !== expectedPkg.version) {
        throw new error_1.HardhatFhevmError(`Invalid ${expectedPkg.name} version. Expecting ${expectedPkg.version}. Got ${pkg.version} instead (at ${pkg.packagePath}).`);
    }
}
function __checkPackages(fhevmPaths) {
    const consumerFhevmSolidityPkg = __requireConsumerResolve(constants_1.default.FHEVM_SOLIDITY_PACKAGE.name, fhevmPaths.rootDir);
    const consumerFhevmHostContractsPkg = __requireConsumerResolve(constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name, fhevmPaths.rootDir);
    const consumerZamaRelayerSdkPkg = __requireConsumerResolve(constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.name, fhevmPaths.rootDir);
    const hhPluginFhevmHostContractsPkg = __requireResolve(constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name);
    const hhPluginFhevmSolidityPkg = __requireResolve(constants_1.default.FHEVM_SOLIDITY_PACKAGE.name);
    const hhPluginZamaRelayerSdkPkg = __requireResolve(constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.name);
    __assertPkgVersion(consumerFhevmHostContractsPkg, constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE);
    __assertPkgVersion(hhPluginFhevmHostContractsPkg, constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE);
    __assertPkgVersion(consumerFhevmSolidityPkg, constants_1.default.FHEVM_SOLIDITY_PACKAGE);
    __assertPkgVersion(hhPluginFhevmSolidityPkg, constants_1.default.FHEVM_SOLIDITY_PACKAGE);
    __assertPkgVersion(consumerZamaRelayerSdkPkg, constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE);
    __assertPkgVersion(hhPluginZamaRelayerSdkPkg, constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE);
    const mockUtilsABIVersion = (0, mock_utils_1.getContractsABIVersions)().ACL;
    if (mockUtilsABIVersion !== constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.version) {
        throw new error_1.HardhatFhevmError(`Internal Error. Expecting ${constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name} version: ${constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.version}. But @fhevm/mock-utils was compiled using ABIs version ${mockUtilsABIVersion}.`);
    }
}
function __checkRelayerSdkAddresses() {
    const expectedACLAddress = constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.sepolia.ACLAddress;
    const expectedKMSVerifierAddress = constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.sepolia.KMSVerifierAddress;
    const expectedInputVerifierAddress = constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.sepolia.InputVerifierAddress;
    const expectedGatewayChainId = constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.sepolia.gatewayChainId;
    const expectedRelayerUrl = constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.sepolia.relayerUrl;
    if (expectedACLAddress !== node_1.SepoliaConfig.aclContractAddress) {
        throw new error_1.HardhatFhevmError(`ACL address missmatch. Unexpected SepoliaConfig.aclContractAddress=${node_1.SepoliaConfig.aclContractAddress} defined in @zama-fhe/relayer-sdk/node. Expected ${expectedACLAddress}.`);
    }
    if (expectedKMSVerifierAddress !== node_1.SepoliaConfig.kmsContractAddress) {
        throw new error_1.HardhatFhevmError(`KMSVerifier address missmatch. Unexpected SepoliaConfig.kmsContractAddress=${node_1.SepoliaConfig.kmsContractAddress} defined in @zama-fhe/relayer-sdk/node. Expected ${expectedKMSVerifierAddress}.`);
    }
    if (expectedInputVerifierAddress !== node_1.SepoliaConfig.inputVerifierContractAddress) {
        throw new error_1.HardhatFhevmError(`InputVerifier address missmatch. Unexpected SepoliaConfig.inputVerifierContractAddress=${node_1.SepoliaConfig.inputVerifierContractAddress} defined in @zama-fhe/relayer-sdk/node. Expected ${expectedInputVerifierAddress}.`);
    }
    if (expectedGatewayChainId !== node_1.SepoliaConfig.gatewayChainId) {
        throw new error_1.HardhatFhevmError(`GatewayChainId missmatch. Unexpected SepoliaConfig.gatewayChainId=${node_1.SepoliaConfig.gatewayChainId} defined in @zama-fhe/relayer-sdk/node. Expected ${expectedGatewayChainId}.`);
    }
    if (!node_1.SepoliaConfig.relayerUrl || new URL(expectedRelayerUrl).href !== new URL(node_1.SepoliaConfig.relayerUrl).href) {
        throw new error_1.HardhatFhevmError(`Relayer Url missmatch. Unexpected SepoliaConfig.relayerUrl=${node_1.SepoliaConfig.relayerUrl} defined in @zama-fhe/relayer-sdk/node. Expected ${expectedRelayerUrl}.`);
    }
}
async function setupMockUsingHostContractsArtifacts(mockProvider, fhevmAddresses, fhevmSigners, fhevmPaths) {
    __checkPackages(fhevmPaths);
    __checkRelayerSdkAddresses();
    const FHEVMExecutorAddress = fhevmAddresses.CoprocessorConfig.CoprocessorAddress;
    const aclAddress = fhevmAddresses.CoprocessorConfig.ACLAddress;
    const kmsVerifierAddress = fhevmAddresses.CoprocessorConfig.KMSVerifierAddress;
    const inputVerifierAddress = fhevmAddresses.InputVerifierAddress;
    const hcuLimitAddress = fhevmAddresses.HCULimitAddress;
    const execArtifact = await fhevmPaths.getFhevmHostContractsArtifact("FHEVMExecutor");
    await __tryDeploy(mockProvider, "FHEVMExecutor", FHEVMExecutorAddress, execArtifact.path, execArtifact.artifact.deployedBytecode);
    const fhevmExecutorReadOnly = new ethers_1.ethers.Contract(FHEVMExecutorAddress, execArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const precompiledACLAddress = (await fhevmExecutorReadOnly.getACLAddress());
    const precompiledHCULimitAddress = (await fhevmExecutorReadOnly.getHCULimitAddress());
    const precompiledInputVerifierAddress = (await fhevmExecutorReadOnly.getInputVerifierAddress());
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledACLAddress, aclAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledHCULimitAddress, hcuLimitAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, precompiledInputVerifierAddress, inputVerifierAddress);
    const aclArtifact = await fhevmPaths.getFhevmHostContractsArtifact("ACL");
    const aclDeployment = await __tryDeploy(mockProvider, "ACL", aclAddress, aclArtifact.path, aclArtifact.artifact.deployedBytecode);
    const kmsArtifact = await fhevmPaths.getFhevmHostContractsArtifact("KMSVerifier");
    const kmsDeployment = await __tryDeploy(mockProvider, "KMSVerifier", kmsVerifierAddress, kmsArtifact.path, kmsArtifact.artifact.deployedBytecode);
    const inputArtifact = await fhevmPaths.getFhevmHostContractsArtifact("InputVerifier");
    const inputVerifierDeployment = await __tryDeploy(mockProvider, "InputVerifier", inputVerifierAddress, inputArtifact.path, inputArtifact.artifact.deployedBytecode);
    const hcuLimitArtifact = await fhevmPaths.getFhevmHostContractsArtifact("HCULimit");
    await __tryDeploy(mockProvider, "HCULimit", hcuLimitAddress, hcuLimitArtifact.path, hcuLimitArtifact.artifact.deployedBytecode);
    const aclReadOnly = new ethers_1.ethers.Contract(aclAddress, aclArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const hcuLimitReadOnly = new ethers_1.ethers.Contract(hcuLimitAddress, hcuLimitArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const inputVerifierReadOnly = new ethers_1.ethers.Contract(inputVerifierAddress, inputArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const kmsVerifierReadOnly = new ethers_1.ethers.Contract(kmsVerifierAddress, kmsArtifact.artifact.abi, mockProvider.readonlyEthersProvider);
    const aclFHEVMExecutorAddress = await __tryCallGetFHEVMExecutorAddress(aclReadOnly, "ACL", aclAddress);
    const hcuLimitFHEVMExecutorAddress = await __tryCallGetFHEVMExecutorAddress(hcuLimitReadOnly, "HCULimit", hcuLimitAddress);
    const fhevmExecutorACLAddress = await __tryCallGetACLAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    const fhevmExecutorHCULimitAddress = await __tryCallGetHCULimitAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    const fhevmExecutorInputVerifierAddress = await __tryCallGetInputVerifierAddress(fhevmExecutorReadOnly, "FHEVMExecutor", FHEVMExecutorAddress);
    __checkHardCodedAddress("ACL", aclAddress, aclFHEVMExecutorAddress, FHEVMExecutorAddress);
    __checkHardCodedAddress("HCULimit", hcuLimitAddress, hcuLimitFHEVMExecutorAddress, FHEVMExecutorAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorACLAddress, aclAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorHCULimitAddress, hcuLimitAddress);
    __checkHardCodedAddress("FHEVMExecutor", FHEVMExecutorAddress, fhevmExecutorInputVerifierAddress, inputVerifierAddress);
    const gatewayDecryptionAddress = (0, addresses_1.getGatewayDecryptionAddress)();
    const gatewayInputVerificationAddress = (0, addresses_1.getGatewayInputVerificationAddress)();
    const gatewayChainId = constants_1.default.ZAMA_FHE_RELAYER_SDK_PACKAGE.sepolia.gatewayChainId;
    const kmsInitialThreshold = (0, addresses_1.getKMSThreshold)();
    const inputVerifierInitialThreshold = (0, addresses_1.getInputVerifierThreshold)();
    const kmsSigners = fhevmSigners.kms;
    if (kmsSigners.length !== 1) {
        throw new error_1.HardhatFhevmError(`Expecting 1 KMS Signer. Got ${kmsSigners.length} instead.`);
    }
    const coprocessorSigners = fhevmSigners.coprocessor;
    if (coprocessorSigners.length !== 1) {
        throw new error_1.HardhatFhevmError(`Expecting 1 Coprocessor Signer. Got ${coprocessorSigners.length} instead.`);
    }
    const zero = fhevmSigners.zero;
    const ACLOwner = fhevmSigners.one;
    await __setContractOwner(mockProvider.minimalProvider, aclReadOnly, "ACL", zero, ACLOwner, aclDeployment.alreadyDeployed);
    if (kmsDeployment.alreadyDeployed) {
        const existingKmsVerifier = await mock_utils_1.contracts.KMSVerifier.create(mockProvider.readonlyEthersProvider, kmsVerifierAddress, kmsArtifact.artifact.abi, {
            signers: kmsSigners,
        });
        await existingKmsVerifier.assertMatchKmsSigners(kmsSigners);
        if (existingKmsVerifier.gatewayChainId !== BigInt(gatewayChainId)) {
            throw new error_1.HardhatFhevmError(`Unexpected KMS Gateway ChainId. Expected ${gatewayChainId}, got ${existingKmsVerifier.gatewayChainId} instead.`);
        }
        if (existingKmsVerifier.getThreshold() !== kmsInitialThreshold) {
            throw new error_1.HardhatFhevmError(`Unexpected KMS Threshold. Expected ${kmsInitialThreshold}, got ${existingKmsVerifier.getThreshold()} instead.`);
        }
    }
    else {
        await (0, mock_utils_1.setInitializableStorage)(mockProvider.minimalProvider, kmsVerifierAddress, {
            initialized: 1n,
            initializing: false,
        });
        const kmsACLOwner = kmsVerifierReadOnly.connect(ACLOwner);
        const tx = await kmsACLOwner.initializeFromEmptyProxy(gatewayDecryptionAddress, gatewayChainId, kmsSigners, kmsInitialThreshold);
        await tx.wait();
        (0, error_2.assertHHFhevm)((await kmsVerifierReadOnly.getThreshold()) === BigInt(kmsInitialThreshold));
        const _kmsSignersAddresses = await kmsVerifierReadOnly.getKmsSigners();
        await (0, ethers_2.assertSignersMatchAddresses)(kmsSigners, _kmsSignersAddresses);
        const _kms712Domain = await kmsVerifierReadOnly.eip712Domain();
        (0, mock_utils_1.assertIsEIP712Domain)(_kms712Domain, "KMSVerifier", {
            name: mock_utils_1.constants.PUBLIC_DECRYPT_EIP712.domain.name,
            version: mock_utils_1.constants.PUBLIC_DECRYPT_EIP712.domain.version,
            chainId: BigInt(gatewayChainId),
            verifyingContract: gatewayDecryptionAddress,
        });
    }
    if (inputVerifierDeployment.alreadyDeployed) {
        const existingInputVerifier = await mock_utils_1.contracts.InputVerifier.create(mockProvider.readonlyEthersProvider, inputVerifierAddress, inputArtifact.artifact.abi, {
            signers: coprocessorSigners,
        });
        await existingInputVerifier.assertMatchCoprocessorSigners(coprocessorSigners);
        if (existingInputVerifier.gatewayChainId !== BigInt(gatewayChainId)) {
            throw new error_1.HardhatFhevmError(`Unexpected InputVerifier Gateway ChainId. Expected ${gatewayChainId}, got ${existingInputVerifier.gatewayChainId} instead.`);
        }
        if (existingInputVerifier.getThreshold() !== inputVerifierInitialThreshold) {
            throw new error_1.HardhatFhevmError(`Unexpected InputVerifier Threshold. Expected ${inputVerifierInitialThreshold}, got ${existingInputVerifier.getThreshold()} instead.`);
        }
    }
    else {
        await (0, mock_utils_1.setInitializableStorage)(mockProvider.minimalProvider, inputVerifierAddress, {
            initialized: 1n,
            initializing: false,
        });
        const inputVerifierACLOwner = inputVerifierReadOnly.connect(ACLOwner);
        const tx = await inputVerifierACLOwner.initializeFromEmptyProxy(gatewayInputVerificationAddress, gatewayChainId, coprocessorSigners, inputVerifierInitialThreshold);
        await tx.wait();
        const _inputSignersAddresses = await inputVerifierReadOnly.getCoprocessorSigners();
        await (0, ethers_2.assertSignersMatchAddresses)(coprocessorSigners, _inputSignersAddresses);
        const _inputVerifier712Domain = await inputVerifierReadOnly.eip712Domain();
        (0, mock_utils_1.assertIsEIP712Domain)(_inputVerifier712Domain, "InputVerifier", {
            name: mock_utils_1.constants.INPUT_VERIFICATION_EIP712.domain.name,
            version: mock_utils_1.constants.INPUT_VERIFICATION_EIP712.domain.version,
            chainId: BigInt(gatewayChainId),
            verifyingContract: gatewayInputVerificationAddress,
        });
    }
    debug(`${picocolors.cyanBright("ACL")} address              : ${aclAddress}`);
    debug(`${picocolors.cyanBright("FHEVMExecutor")} address    : ${FHEVMExecutorAddress}`);
    debug(`${picocolors.cyanBright("InputVerifier")} address    : ${inputVerifierAddress}`);
    debug(`${picocolors.cyanBright("KMSVerifier")} address      : ${kmsVerifierAddress}`);
    debug(`Gateway chainId                    : ${gatewayChainId}`);
    debug(`Gateway Input verification address : ${gatewayInputVerificationAddress}`);
    debug(`Gateway Decryption address         : ${gatewayDecryptionAddress}`);
    const repo = await mock_utils_1.contracts.FhevmContractsRepository.create(mockProvider.readonlyEthersProvider, {
        aclContractAddress: aclAddress,
        aclAbi: aclArtifact.artifact.abi,
        aclProperties: {
            fhevmExecutorAddress: aclFHEVMExecutorAddress,
        },
        fhevmExecutorAbi: execArtifact.artifact.abi,
        fhevmExecutorProperties: {
            aclAddress: fhevmExecutorACLAddress,
            hcuLimitAddress: fhevmExecutorHCULimitAddress,
            inputVerifierAddress: fhevmExecutorInputVerifierAddress,
        },
        hcuLimitAbi: hcuLimitArtifact.artifact.abi,
        inputVerifierAbi: inputArtifact.artifact.abi,
        inputVerifierProperties: {
            signers: coprocessorSigners,
        },
        kmsContractAddress: kmsVerifierAddress,
        kmsVerifierAbi: kmsArtifact.artifact.abi,
        kmsVerifierProperties: {
            signers: kmsSigners,
        },
    });
    return {
        contracts: repo,
        gatewayInputVerificationAddress: gatewayInputVerificationAddress,
        gatewayChainId,
        gatewayDecryptionAddress: gatewayDecryptionAddress,
    };
}
function __checkHardCodedAddress(contractName, contractAddress, hardCodedAddress, expectedHardCodedAddress) {
    if (hardCodedAddress !== expectedHardCodedAddress) {
        debug(`${picocolors.bgRedBright(picocolors.bold("ERROR"))} deployed ${contractName} contact at ${contractAddress} does not use the expected ACL address. Got ${hardCodedAddress}, expecting ${expectedHardCodedAddress}`);
        throw new error_1.HardhatFhevmError(`Unable to deploy ${constants_1.default.FHEVM_HOST_CONTRACTS_PACKAGE.name} contracts. (__checkHardCodedAddress(${contractName}, contractAddress: ${contractAddress}, hardCodedAddress: ${hardCodedAddress}, expectedHardCodedAddress: ${expectedHardCodedAddress}))`);
    }
}
async function __setContractOwner(provider, contract, contractName, currentOwnerSigner, newOwnerSigner, alreadyDeployed) {
    const ownerAddress = await contract.owner();
    const contractAddress = await contract.getAddress();
    const currentOwnerAddress = await currentOwnerSigner.getAddress();
    const newOwnerAddress = await newOwnerSigner.getAddress();
    if (alreadyDeployed) {
        if (ownerAddress !== newOwnerAddress) {
            throw new error_1.HardhatFhevmError(`Wrong ${contractName} owner address. Got ${ownerAddress}, expected ${newOwnerAddress}`);
        }
    }
    else {
        if (ownerAddress !== currentOwnerAddress) {
            throw new error_1.HardhatFhevmError(`Wrong ${contractName} owner address. Got ${ownerAddress}, expected ${currentOwnerAddress}`);
        }
    }
    if (ownerAddress === newOwnerAddress) {
        return;
    }
    await (0, mock_utils_1.setOwnableStorage)(provider, contractAddress, newOwnerAddress);
    (0, error_2.assertHHFhevm)((await contract.owner()) === (await newOwnerSigner.getAddress()), `Set ${contractName} owner failed. Unexpected contract owner.`);
}
//# sourceMappingURL=setup.js.map